
const puppeteer = require('puppeteer-extra');
const stealth = require('puppeteer-extra-plugin-stealth');
const {executablePath} = require('puppeteer');

// Define TikTok related constants here
const tiktokBaseUrl = "https://tiktok.com/";
const tiktokLoginUrl = "login/phone-or-email/email/";

// Define control flow related constants here
const maxHits = 100;

// Define constants for selectors here
const SEL_VIDEO_DIV = 'div.tiktok-x6y88p-DivItemContainerV2.e19c29qe7';
const SEL_LIKE_DIV = 'div[class*="DivLikeWrapper-StyledLikeWrapper"]';
const SEL_COMMENTS_DIV = 'div[class*="DivCommentContainer"]';
const SEL_VIDEO_LIST_DIV = 'div[class*="DivVideoList"]';
const SEL_EMAIL_FIELD = 'input[name="username"]';
const SEL_PASSWORD_FIELD = 'input[type="password"]';

puppeteer.use(stealth())

let browser;
let page;

async function presentLogin(email, password) {
	browser = await puppeteer.launch({
  	headless: false,
  	executablePath: executablePath()
	});
	page = await browser.newPage();

	await page.goto(tiktokBaseUrl + tiktokLoginUrl);

  if (email !== '') {
  	await page.waitForSelector(SEL_EMAIL_FIELD);
  	await page.type(SEL_EMAIL_FIELD, email);
  	await page.type(SEL_PASSWORD_FIELD, password);
  }
}

async function getVideoUrls(username) {
	await page.goto(tiktokBaseUrl + '@' + username);
  await page.waitForSelector(SEL_VIDEO_DIV);

  await page.evaluate(async (SEL_VIDEO_DIV) => {
    const sleep = ms => new Promise(r => setTimeout(r, ms));

    while (true) {
      await window.scrollBy(0, window.innerHeight);
      await sleep(1000);
      if (document.querySelectorAll(SEL_VIDEO_DIV).length > 50) {
        break;
      }
    }
  }, SEL_VIDEO_DIV);

  const videoDivs = await page.$$(SEL_VIDEO_DIV);
  let videoUrls = [];

	for (var i = videoDivs.length - 1; i >= 0; i--) {
		const url = await videoDivs[i].$eval('a', a => {
			if (typeof a.getAttribute === 'function') {
				return a.getAttribute('href');
			} else {
				return "";
			}
		});
		if (url !== "") {
			videoUrls.push(url);
		}
	}
	return videoUrls;
}

async function likeComments(videoUrl) {
	let commentPage = await browser.newPage();
	await commentPage.goto(videoUrl);
  await commentPage.waitForSelector(SEL_LIKE_DIV);
  
  const count = await commentPage.evaluate(async (SEL_LIKE_DIV, SEL_COMMENTS_DIV, SEL_VIDEO_LIST_DIV, maxHits) => {
    let count = 0;
    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // Remove the video list on the right because it will always produce more videos
    document.querySelector(SEL_VIDEO_LIST_DIV).remove();

    // Keep track of where we scrolled to on the last iteration
    // If the comments list height doesn't change, then
    // we most likely hit the bottom of the list
    let oldHeight = 0;
    let hits = 0;

    let finished = false;
    while (!finished) {
    	const results = document.querySelectorAll(SEL_LIKE_DIV);
    	for (var i = 0; i < results.length; i++) {

    		// Liked comments have a g tag so we want to skip them
    		if (results[i].querySelector('g') == null) {
    			await sleep(1000);
    			results[i].click();
          count ++;
    		}
    	}
      await window.scrollBy(0, window.innerHeight);

      // Wait for new comments to load
      await sleep(2000);

      // If the comments div hasn't gotten taller then we've likely hit the end
      const height = document.querySelector(SEL_COMMENTS_DIV).getBoundingClientRect().height;
      if (height == oldHeight) {
        hits++;
        console.log("Hits: " + hits);
        if (hits == maxHits) {
          console.log("Finished");
          finished = true;
        }
      } else {
        hits = 0;
        oldHeight = height;
      }
    }
    return count;
  }, SEL_LIKE_DIV, SEL_COMMENTS_DIV, SEL_VIDEO_LIST_DIV, maxHits).catch((e) => {
    console.log('Error liking comments: ' + e);
  });
  return count;
}

module.exports = {
	presentLogin,
	getVideoUrls,
	likeComments,
}